{% extends "myapp/base.html" %}
{% load static %}

{% block title %}Meme Board{% endblock %}

{% block content %}
<div class="meme-toolbar-sticky d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2">
    <h1 class="h3 mb-0 flex-grow-0">
      {% if random_mode %}
        Randomized Feed
      {% else %}
        Public Feed
      {% endif %}
    </h1>

  <div class="d-flex align-items-center gap-2 flex-grow-1 justify-content-end">
    <!-- Tag search, smaller + max width -->
    <div class="position-relative" style="max-width: 260px; width: 100%;">
      <input type="text"
             id="tag-filter-input"
             class="form-control form-control-sm"
             placeholder="Filter by tag">
        <div id="tag-filter-suggestions"
             class="position-absolute w-100 bg-body border border-secondary-subtle mt-1 rounded-3 shadow-sm d-none"
             style="z-index: 1000;">
        </div>
    </div>

    <a href="{% url 'myapp:meme_upload' %}" class="btn btn-primary btn-sm">
      Upload
    </a>
  </div>
</div>

{% if current_tag %}
  <div class="mb-3">
    <span class="badge bg-primary">
      Filter: #{{ current_tag.name }}
    </span>
    <a href="{% url 'myapp:meme_list' %}" class="btn btn-sm btn-outline-secondary ms-2">
      Clear
    </a>
  </div>
{% endif %}

<div class="row row-cols-1 row-cols-md-3 row-cols-lg-4 row-cols-xl-5 row-cols-xxl-5 g-4" id="meme-grid">
  {% include "myapp/partials/meme_grid.html" %}
</div>

<!-- Fallback pagination for no-JS -->
<nav aria-label="Page navigation" class="mt-4 d-none" id="pagination-fallback">
  <ul class="pagination justify-content-center">
    {% if page_obj.has_previous %}
      <li class="page-item">
        <a class="page-link" href="?page={{ page_obj.previous_page_number }}">Previous</a>
      </li>
    {% else %}
      <li class="page-item disabled"><span class="page-link">Previous</span></li>
    {% endif %}

    <li class="page-item disabled">
      <span class="page-link">
        Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}
      </span>
    </li>

    {% if page_obj.has_next %}
      <li class="page-item">
        <a class="page-link" href="?page={{ page_obj.next_page_number }}">Next</a>
      </li>
    {% else %}
      <li class="page-item disabled"><span class="page-link">Next</span></li>
    {% endif %}
  </ul>
</nav>

<div id="infinite-loader" class="text-center my-4 d-none">
  <div class="spinner-border text-secondary" role="status">
    <span class="visually-hidden">Loading...</span>
  </div>
</div>
<div id="scroll-sentinel" class="my-4"></div>

<!-- Modern Lightbox Overlay -->
<div id="meme-lightbox" class="lightbox-overlay">
  <div class="lightbox-container">
    <!-- Close button -->
    <button type="button" class="lightbox-close" id="lightbox-close" aria-label="Close">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
      </svg>
    </button>

    <!-- Navigation zones -->
    <div class="lightbox-nav-left" id="lightbox-nav-left" title="Previous (←)"></div>
    <div class="lightbox-nav-right" id="lightbox-nav-right" title="Next (→)"></div>

    <!-- Content area -->
    <div class="lightbox-content" id="lightbox-content">
      <div class="lightbox-media-container" id="lightbox-media"></div>
    </div>

    <!-- Bottom info bar -->
    <div class="lightbox-info" id="lightbox-info">
      <div class="lightbox-title" id="lightbox-title"></div>
      <div class="lightbox-meta" id="lightbox-meta"></div>
    </div>

    <!-- Counter -->
    <div class="lightbox-counter" id="lightbox-counter"></div>
  </div>
</div>

<style>
  .lightbox-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.95);
    z-index: 10000;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .lightbox-overlay.active {
    display: flex;
    opacity: 1;
  }

  .lightbox-container {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
  }

  .lightbox-close {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 44px;
    height: 44px;
    border: none;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    color: white;
    border-radius: 50%;
    cursor: pointer;
    z-index: 10002;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }

  .lightbox-close:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: scale(1.1);
  }

  .lightbox-nav-left,
  .lightbox-nav-right {
    position: absolute;
    top: 0;
    bottom: 80px;
    width: 30%;
    cursor: pointer;
    z-index: 10001;
    display: flex;
    align-items: center;
    transition: background 0.2s ease;
  }

  .lightbox-nav-left {
    left: 0;
    justify-content: flex-start;
    padding-left: 20px;
  }

  .lightbox-nav-right {
    right: 0;
    justify-content: flex-end;
    padding-right: 20px;
  }

  .lightbox-nav-left:hover,
  .lightbox-nav-right:hover {
    background: rgba(255, 255, 255, 0.03);
  }

  .lightbox-nav-left::before,
  .lightbox-nav-right::before {
    content: '';
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.2s ease;
    font-size: 24px;
    color: white;
  }

  .lightbox-nav-left:hover::before,
  .lightbox-nav-right:hover::before {
    opacity: 1;
  }

  .lightbox-nav-left::before {
    content: '‹';
    line-height: 40px;
    text-align: center;
  }

  .lightbox-nav-right::before {
    content: '›';
    line-height: 40px;
    text-align: center;
  }

  .lightbox-content {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 80px 20px 100px;
    overflow: hidden;
  }

  .lightbox-media-container {
    max-width: 100%;
    max-height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .lightbox-media-container img,
  .lightbox-media-container video {
    display: block;
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    object-fit: contain;
    border-radius: 4px;
    box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
  }

  .lightbox-info {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 20px 40px;
    background: linear-gradient(to top, rgba(0, 0, 0, 0.9), transparent);
    color: white;
    z-index: 10001;
  }

  .lightbox-title {
    font-size: 1.25rem;
    font-weight: 600;
    margin-bottom: 5px;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
  }

  .lightbox-meta {
    font-size: 0.9rem;
    opacity: 0.9;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
  }

  .lightbox-meta a {
    color: #6ea8fe;
    text-decoration: none;
  }

  .lightbox-meta a:hover {
    text-decoration: underline;
  }

  .lightbox-counter {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    padding: 8px 16px;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    color: white;
    border-radius: 20px;
    font-size: 0.9rem;
    z-index: 10002;
  }

  /* Loading animation */
  .lightbox-media-container.loading::after {
    content: '';
    width: 40px;
    height: 40px;
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-top-color: white;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Mobile adjustments */
  @media (max-width: 768px) {
    .lightbox-nav-left,
    .lightbox-nav-right {
      width: 25%;
    }

    .lightbox-info {
      padding: 15px 20px;
    }

    .lightbox-title {
      font-size: 1rem;
    }

    .lightbox-meta {
      font-size: 0.8rem;
    }

    .lightbox-close {
      top: 10px;
      right: 10px;
    }
  }
</style>

<script>
    // Infinite scroll
    (function() {
      const grid = document.getElementById("meme-grid");
      const sentinel = document.getElementById("scroll-sentinel");
      const loader = document.getElementById("infinite-loader");
      const paginationFallback = document.getElementById("pagination-fallback");

      if (!grid || !sentinel) {
        return;
      }

      if (paginationFallback) {
        paginationFallback.classList.add("d-none");
      }

      let nextPage = {% if page_obj.has_next %}{{ page_obj.next_page_number }}{% else %}null{% endif %};
      let loading = false;

      function loadMore() {
        if (!nextPage || loading) {
          return;
        }
        loading = true;
        if (loader) {
          loader.classList.remove("d-none");
        }

        const url = new URL(window.location.href);
        url.searchParams.set("page", nextPage);

        fetch(url.toString(), {
          headers: {
            "X-Requested-With": "XMLHttpRequest"
          }
        })
        .then(response => response.json())
        .then(data => {
          if (data.html) {
            grid.insertAdjacentHTML("beforeend", data.html);
          }

          if (data.has_next) {
            nextPage = data.next_page_number;
          } else {
            nextPage = null;
            if (observer) {
              observer.disconnect();
            }
          }
        })
        .catch(err => {
          console.error("Error loading more memes:", err);
        })
        .finally(() => {
          loading = false;
          if (loader) {
            loader.classList.add("d-none");
          }
        });
      }

      const observer = new IntersectionObserver(entries => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            loadMore();
          }
        });
      }, {
        root: null,
        rootMargin: "200px",
        threshold: 0
      });

      if (nextPage) {
        observer.observe(sentinel);
      }
    })();

    // Tag search & suggestions
    (function() {
      const input = document.getElementById("tag-filter-input");
      const box = document.getElementById("tag-filter-suggestions");
      if (!input || !box) return;

      let timeout = null;

      function renderSuggestions(results) {
        if (!results.length) {
          box.classList.add("d-none");
          box.innerHTML = "";
          return;
        }

        box.innerHTML = "";
        results.forEach(tag => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "btn btn-sm btn-outline-secondary m-1";
          btn.textContent = "#" + tag.name;
          btn.addEventListener("click", function() {
            const url = new URL(window.location.href);
            url.searchParams.set("tag", tag.slug);
            url.searchParams.delete("page");
            window.location.href = url.toString();
          });
          box.appendChild(btn);
        });
        box.classList.remove("d-none");
      }

      function fetchSuggestions(query) {
        const url = "{% url 'myapp:tag_suggestions' %}?q=" + encodeURIComponent(query || "");

        fetch(url, {
          headers: {
            "X-Requested-With": "XMLHttpRequest"
          }
        })
        .then(res => res.json())
        .then(data => {
          renderSuggestions(data.results || []);
        })
        .catch(() => {
          box.classList.add("d-none");
        });
      }

      input.addEventListener("input", function() {
        const value = input.value.trim();
        if (timeout) {
          clearTimeout(timeout);
        }
        timeout = setTimeout(() => fetchSuggestions(value), 200);
      });

      input.addEventListener("focus", function() {
        if (!input.value.trim()) {
          fetchSuggestions("");
        }
      });

      document.addEventListener("click", function(e) {
        if (!box.contains(e.target) && e.target !== input) {
          box.classList.add("d-none");
        }
      });
    })();

    // Modern Lightbox
    (function() {
      const lightbox = document.getElementById("meme-lightbox");
      const mediaContainer = document.getElementById("lightbox-media");
      const titleEl = document.getElementById("lightbox-title");
      const metaEl = document.getElementById("lightbox-meta");
      const counterEl = document.getElementById("lightbox-counter");
      const closeBtn = document.getElementById("lightbox-close");
      const navLeft = document.getElementById("lightbox-nav-left");
      const navRight = document.getElementById("lightbox-nav-right");

      if (!lightbox) return;

      let items = [];
      let currentIndex = -1;
      let touchStartX = 0;
      let touchStartY = 0;

      function decodeText(text) {
        if (!text) return "";
        return text.replace(/\\u[\dA-Fa-f]{4}/g, function(match) {
          return String.fromCharCode(parseInt(match.replace(/\\u/g, ''), 16));
        });
      }

      function collectItems() {
        items = Array.from(document.querySelectorAll("[data-meme-open]"));
      }

      function showLightbox() {
        lightbox.style.display = "flex";
        setTimeout(() => lightbox.classList.add("active"), 10);
        document.body.style.overflow = "hidden";
      }

      function hideLightbox() {
        lightbox.classList.remove("active");
        setTimeout(() => {
          lightbox.style.display = "none";
          document.body.style.overflow = "";
        }, 300);
      }

      function renderMedia() {
        if (currentIndex < 0 || currentIndex >= items.length) return;

        const el = items[currentIndex];
        const type = el.dataset.mediaType || "image";
        const url = el.dataset.fullUrl;
        const title = decodeText(el.dataset.title || "Meme");
        const uploader = decodeText(el.dataset.uploader || "Unknown");
        const created = el.dataset.created || "";
        const detailUrl = el.dataset.detailUrl || "#";

        // Clear previous content
        mediaContainer.innerHTML = "";
        mediaContainer.classList.add("loading");

        // Create media element
        if (type === "video") {
          const video = document.createElement("video");
          video.controls = true;
          video.autoplay = true;

          video.addEventListener("loadeddata", () => {
            mediaContainer.classList.remove("loading");
            scaleMedia(video);
          });

          const source = document.createElement("source");
          source.src = url;
          video.appendChild(source);
          mediaContainer.appendChild(video);
        } else {
          const img = new Image();

          img.onload = function() {
            mediaContainer.classList.remove("loading");
            scaleMedia(img);
          };

          img.onerror = function() {
            mediaContainer.classList.remove("loading");
          };

          img.src = url;
          img.alt = title;
          mediaContainer.appendChild(img);
        }

        // Update info
        titleEl.textContent = title;

        metaEl.innerHTML = "";
        const uploaderSpan = document.createElement("span");
        uploaderSpan.textContent = `by ${uploader} · ${created} · `;
        metaEl.appendChild(uploaderSpan);

        const detailLink = document.createElement("a");
        detailLink.href = detailUrl;
        detailLink.textContent = "View details";
        metaEl.appendChild(detailLink);

        // Update counter
        counterEl.textContent = `${currentIndex + 1} / ${items.length}`;

        // Update navigation state
        navLeft.style.display = currentIndex > 0 ? "flex" : "none";
        navRight.style.display = currentIndex < items.length - 1 ? "flex" : "none";
      }

      function scaleMedia(media) {
        // Get viewport dimensions (accounting for padding and info bar)
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight - 200; // Reserve space for info

        let naturalWidth, naturalHeight;

        if (media.tagName === "VIDEO") {
          naturalWidth = media.videoWidth;
          naturalHeight = media.videoHeight;
        } else {
          naturalWidth = media.naturalWidth;
          naturalHeight = media.naturalHeight;
        }

        // Calculate scaling to fill viewport while maintaining aspect ratio
        const widthScale = (viewportWidth * 0.7) / naturalWidth;
        const heightScale = (viewportHeight * 0.7) / naturalHeight;

        // Use the larger scale to ensure the image fills the space
        // but cap at 2x for very small images
        const scale = Math.min(Math.max(widthScale, heightScale), 2);

        const displayWidth = naturalWidth * scale;
        const displayHeight = naturalHeight * scale;

        media.style.width = displayWidth + "px";
        media.style.height = displayHeight + "px";
      }

      function openLightbox(el) {
        collectItems();
        currentIndex = items.indexOf(el);
        if (currentIndex === -1) return;

        showLightbox();
        renderMedia();
      }

      function goToPrevious() {
        if (currentIndex > 0) {
          currentIndex--;
          renderMedia();
        }
      }

      function goToNext() {
        if (currentIndex < items.length - 1) {
          currentIndex++;
          renderMedia();
        }
      }

      // Event listeners
      document.addEventListener("click", function(e) {
        const target = e.target.closest("[data-meme-open]");
        if (target) {
          e.preventDefault();
          openLightbox(target);
        }
      });

      closeBtn.addEventListener("click", hideLightbox);

      navLeft.addEventListener("click", goToPrevious);
      navRight.addEventListener("click", goToNext);

      // Keyboard navigation
      document.addEventListener("keydown", function(e) {
        if (!lightbox.classList.contains("active")) return;

        if (e.key === "Escape") {
          e.preventDefault();
          hideLightbox();
        } else if (e.key === "ArrowLeft") {
          e.preventDefault();
          goToPrevious();
        } else if (e.key === "ArrowRight") {
          e.preventDefault();
          goToNext();
        }
      });

      // Touch gestures
      lightbox.addEventListener("touchstart", function(e) {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
      }, false);

      lightbox.addEventListener("touchend", function(e) {
        const touchEndX = e.changedTouches[0].screenX;
        const touchEndY = e.changedTouches[0].screenY;

        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;

        const minSwipeDistance = 50;
        if (Math.abs(deltaX) > minSwipeDistance && Math.abs(deltaX) > Math.abs(deltaY)) {
          if (deltaX > 0) {
            goToPrevious();
          } else {
            goToNext();
          }
        }
      }, false);

      // Close on background click
      lightbox.addEventListener("click", function(e) {
        if (e.target === lightbox || e.target.closest(".lightbox-content")) {
          hideLightbox();
        }
      });

      // Resize handler
      window.addEventListener("resize", function() {
        if (lightbox.classList.contains("active")) {
          const media = mediaContainer.querySelector("img, video");
          if (media) {
            scaleMedia(media);
          }
        }
      });
    })();
  </script>

{% endblock %}
