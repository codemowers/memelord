{% extends "myapp/base.html" %}
{% load static %}

{% block title %}Meme Board{% endblock %}

{% block content %}
<div class="meme-toolbar-sticky d-flex justify-content-between align-items-center mb-3 flex-wrap gap-2">
    <h1 class="h3 mb-0 flex-grow-0">
      {% if random_mode %}
        Randomized Feed
      {% else %}
        Public Feed
      {% endif %}
    </h1>

  <div class="d-flex align-items-center gap-2 flex-grow-1 justify-content-end">
    <!-- Tag search -->
    <div class="position-relative" style="max-width: 260px; width: 100%;">
      <input type="text"
             id="tag-filter-input"
             class="form-control form-control-sm"
             placeholder="Filter by tag">
        <div id="tag-filter-suggestions"
             class="position-absolute w-100 bg-body border border-secondary-subtle mt-1 rounded-3 shadow-sm d-none"
             style="z-index: 1000; max-height: 300px; overflow-y: auto;">
        </div>
    </div>

    <a href="{% url 'myapp:meme_upload' %}" class="btn btn-primary btn-sm">
      Upload
    </a>
  </div>
</div>

{% if current_tag %}
  <div class="mb-3">
    <span class="badge bg-primary">
      Filter: #{{ current_tag.name }}
    </span>
    <a href="{% url 'myapp:meme_list' %}" class="btn btn-sm btn-outline-secondary ms-2">
      Clear
    </a>
  </div>
{% endif %}

<div class="row row-cols-2 row-cols-md-3 row-cols-lg-4 row-cols-xl-5 row-cols-xxl-5 g-4" id="meme-grid">
  {% include "myapp/partials/meme_grid.html" %}
</div>

<!-- Fallback pagination (no JS) -->
<nav aria-label="Page navigation" class="mt-4 d-none" id="pagination-fallback">
  <ul class="pagination justify-content-center">
    {% if page_obj.has_previous %}
      <li class="page-item"><a class="page-link" href="?page={{ page_obj.previous_page_number }}">Previous</a></li>
    {% else %}
      <li class="page-item disabled"><span class="page-link">Previous</span></li>
    {% endif %}

    <li class="page-item disabled">
      <span class="page-link">Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}</span>
    </li>

    {% if page_obj.has_next %}
      <li class="page-item"><a class="page-link" href="?page={{ page_obj.next_page_number }}">Next</a></li>
    {% else %}
      <li class="page-item disabled"><span class="page-link">Next</span></li>
    {% endif %}
  </ul>
</nav>

<div id="infinite-loader" class="text-center my-4 d-none">
  <div class="spinner-border text-secondary" role="status">
    <span class="visually-hidden">Loading...</span>
  </div>
</div>
<div id="scroll-sentinel" class="my-4"></div>

<!-- Modern Lightbox Overlay -->
<div id="meme-lightbox" class="lightbox-overlay">
  <div class="lightbox-container">
    <button type="button" class="lightbox-close" id="lightbox-close" aria-label="Close">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
      </svg>
    </button>

    <div class="lightbox-nav-left" id="lightbox-nav-left" title="Previous (Left Arrow)"></div>
    <div class="lightbox-nav-right" id="lightbox-nav-right" title="Next (Right Arrow)"></div>

    <div class="lightbox-content" id="lightbox-content">
      <div class="lightbox-media-container" id="lightbox-media"></div>
    </div>

    <div class="lightbox-info" id="lightbox-info">
      <div class="lightbox-title" id="lightbox-title"></div>
      <div class="lightbox-meta" id="lightbox-meta"></div>
    </div>

    <div class="lightbox-counter" id="lightbox-counter"></div>
  </div>
</div>

<style>
  .lightbox-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.95);
    z-index: 10000;
    opacity: 0;
    transition: opacity 0.3s ease;
    align-items: center;
    justify-content: center;
  }
  .lightbox-overlay.active { display: flex; opacity: 1; }

  .lightbox-close, .lightbox-nav-left::before, .lightbox-nav-right::before, .lightbox-counter {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
  }
  .lightbox-close { position: absolute; top: 20px; right: 20px; width: 44px; height: 44px; border: none; border-radius: 50%; color: white; cursor: pointer; z-index: 10002; }
  .lightbox-close:hover { background: rgba(255, 255, 255, 0.2); transform: scale(1.1); }

  .lightbox-nav-left, .lightbox-nav-right {
    position: absolute;
    top: 0; bottom: 80px;
    width: 30%;
    cursor: pointer;
    z-index: 10001;
    display: flex;
    align-items: center;
  }
  .lightbox-nav-left { left: 0; justify-content: flex-start; padding-left: 20px; }
  .lightbox-nav-right { right: 0; justify-content: flex-end; padding-right: 20px; }
  .lightbox-nav-left:hover, .lightbox-nav-right:hover { background: rgba(255, 255, 255, 0.03); }
  .lightbox-nav-left::before { content: '‹'; font-size: 40px; opacity: 0; transition: opacity 0.2s; }
  .lightbox-nav-right::before { content: '›'; font-size: 40px; opacity: 0; transition: opacity 0.2s; }
  .lightbox-nav-left:hover::before, .lightbox-nav-right:hover::before { opacity: 1; }

  .lightbox-content { flex: 1; display: flex; align-items: center; justify-content: center; padding: 80px 20px 100px; }
  .lightbox-media-container { max-width: 100%; max-height: 100%; display: flex; align-items: center; justify-content: center; position: relative; }
  .lightbox-media-container img,
  .lightbox-media-container video {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    border-radius: 8px;
    box-shadow: 0 10px 60px rgba(0, 0, 0, 0.7);
    transition: width 0.35s cubic-bezier(0.2, 0.8, 0.4, 1), height 0.35s cubic-bezier(0.2, 0.8, 0.4, 1);
    image-rendering: -webkit-optimize-contrast;
  }

  .lightbox-info {
    position: absolute;
    bottom: 0; left: 0; right: 0;
    padding: 20px 40px;
    background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
    color: white;
    z-index: 10001;
  }
  .lightbox-title { font-size: 1.25rem; font-weight: 600; margin-bottom: 5px; }
  .lightbox-meta { font-size: 0.9rem; opacity: 0.9; }
  .lightbox-meta a { color: #6ea8fe; text-decoration: none; }
  .lightbox-meta a:hover { text-decoration: underline; }

  .lightbox-counter {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    padding: 8px 16px;
    border-radius: 20px;
    color: white;
    font-size: 0.9rem;
    z-index: 10002;
  }

  /* Loading spinner */
  .lightbox-media-container.loading::after {
    content: '';
    position: absolute;
    width: 50px; height: 50px;
    border: 4px solid rgba(255,255,255,0.3);
    border-top-color: white;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  @media (max-width: 768px) {
    .lightbox-info { padding: 15px 20px; }
    .lightbox-title { font-size: 1rem; }
    .lightbox-close { top: 10px; right: 10px; }
    .lightbox-nav-left, .lightbox-nav-right { width: 25%; }
  }

  .lightbox-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  align-items: center;
}

.lightbox-tag-badge {
  display: inline-block;
  padding: 4px 10px;
  background: rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(10px);
  border-radius: 12px;
  color: #6ea8fe;
  text-decoration: none;
  font-size: 0.85rem;
  transition: all 0.2s ease;
}

.lightbox-tag-badge:hover {
  background: rgba(255, 255, 255, 0.25);
  color: #9ec5fe;
  text-decoration: none;
  transform: translateY(-1px);
}
</style>

<script>
  // === Infinite Scroll ===
  (function() {
    const grid = document.getElementById("meme-grid");
    const sentinel = document.getElementById("scroll-sentinel");
    const loader = document.getElementById("infinite-loader");
    if (!grid || !sentinel) return;

    let nextPage = {% if page_obj.has_next %}{{ page_obj.next_page_number }}{% else %}null{% endif %};
    let loading = false;

    function loadMore() {
      if (!nextPage || loading) return;
      loading = true;
      loader?.classList.remove("d-none");

      const url = new URL(window.location.href);
      url.searchParams.set("page", nextPage);

      fetch(url, { headers: { "X-Requested-With": "XMLHttpRequest" } })
        .then(r => r.json())
        .then(data => {
          if (data.html) grid.insertAdjacentHTML("beforeend", data.html);
          nextPage = data.has_next ? data.next_page_number : null;
          if (!nextPage && observer) observer.disconnect();
        })
        .finally(() => {
          loading = false;
          loader?.classList.add("d-none");
        });
    }

    const observer = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting) loadMore();
    }, { rootMargin: "300px" });

    if (nextPage) observer.observe(sentinel);
  })();

  // === Tag Suggestions ===
  (function() {
    const input = document.getElementById("tag-filter-input");
    const box = document.getElementById("tag-filter-suggestions");
    if (!input || !box) return;

    let timeout = null;
    function fetchSuggestions(q) {
      fetch("{% url 'myapp:tag_suggestions' %}?q=" + encodeURIComponent(q))
        .then(r => r.json())
        .then(data => {
          box.innerHTML = "";
          if (!data.results?.length) return box.classList.add("d-none");
          data.results.forEach(tag => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "btn btn-sm btn-outline-secondary m-1";
            btn.textContent = "#" + tag.name;
            btn.onclick = () => {
              const url = new URL(window.location);
              url.searchParams.set("tag", tag.slug);
              url.searchParams.delete("page");
              location.href = url;
            };
            box.appendChild(btn);
          });
          box.classList.remove("d-none");
        });
    }

    input.addEventListener("input", () => {
      clearTimeout(timeout);
      timeout = setTimeout(() => fetchSuggestions(input.value.trim()), 200);
    });
    input.addEventListener("focus", () => !input.value.trim() && fetchSuggestions(""));
    document.addEventListener("click", e => {
      if (!box.contains(e.target) && e.target !== input) box.classList.add("d-none");
    });
  })();

// === Smart Lightbox with Infinite Scroll Integration ===
// === Smart Lightbox with Infinite Scroll Integration and Tags ===
(function() {
  const lightbox = document.getElementById("meme-lightbox");
  const mediaContainer = document.getElementById("lightbox-media");
  const titleEl = document.getElementById("lightbox-title");
  const metaEl = document.getElementById("lightbox-meta");
  const counterEl = document.getElementById("lightbox-counter");
  const closeBtn = document.getElementById("lightbox-close");
  const navLeft = document.getElementById("lightbox-nav-left");
  const navRight = document.getElementById("lightbox-nav-right");
  const grid = document.getElementById("meme-grid");

  let items = [];
  let currentIndex = -1;
  let isLoadingMore = false;

  // Access infinite scroll state from the other script
  let infiniteScrollState = {
    nextPage: {% if page_obj.has_next %}{{ page_obj.next_page_number }}{% else %}null{% endif %},
    loading: false
  };

  function collectItems() {
    items = Array.from(document.querySelectorAll("[data-meme-open]"));
  }

  function show() {
    lightbox.style.display = "flex";
    setTimeout(() => lightbox.classList.add("active"), 10);
    document.body.style.overflow = "hidden";
  }

  function hide() {
    lightbox.classList.remove("active");
    setTimeout(() => {
      lightbox.style.display = "none";
      document.body.style.overflow = "";
    }, 300);
  }

  function decodeText(t) { 
    return t ? t.replace(/\\u[\dA-Fa-f]{4}/g, m => String.fromCharCode(parseInt(m.slice(2), 16))) : ""; 
  }

  function scaleMedia(media) {
    media.style.width = media.style.height = media.style.maxWidth = media.style.maxHeight = "";

    requestAnimationFrame(() => {
      let nw, nh;
      if (media.tagName === "VIDEO") {
        nw = media.videoWidth;
        nh = media.videoHeight;
        if (!nw || !nh) return;
      } else {
        nw = media.naturalWidth;
        nh = media.naturalHeight;
        if (!nw || !nh) return;
      }

      const ar = nw / nh;
      const vw = window.innerWidth;
      const vh = window.innerHeight - 160;

      const maxW = vw * 0.94;
      const maxH = vh * 0.92;

      let w, h;

      if (ar > 1) {
        w = Math.min(nw, maxW);
        h = w / ar;
        if (h > maxH) { h = maxH; w = h * ar; }
      } else {
        h = Math.min(nh, maxH);
        w = h * ar;
        if (w < vw * 0.5 && nh <= maxH * 1.5) {
          const upH = maxH * 1.5;
          const upW = upH * ar;
          if (upW <= maxW) { h = upH; w = upW; }
        }
        if (w > maxW) { w = maxW; h = w / ar; }
      }

      w = Math.min(w, maxW);
      h = Math.min(h, maxH);

      media.style.transition = "width 0.35s ease, height 0.35s ease";
      media.style.width = w + "px";
      media.style.height = h + "px";
    });
  }

  function renderMedia() {
    if (currentIndex < 0 || currentIndex >= items.length) return;
    const el = items[currentIndex];
    const type = el.dataset.mediaType || "image";
    const url = el.dataset.fullUrl;
    const title = decodeText(el.dataset.title || "Meme");
    const uploader = decodeText(el.dataset.uploader || "Anonymous");
    const created = el.dataset.created || "";
    const detailUrl = el.dataset.detailUrl || "#";
    const tagsJson = el.dataset.tags || "[]";

    mediaContainer.innerHTML = "";
    mediaContainer.classList.add("loading");

    if (type === "video") {
      const video = document.createElement("video");
      video.controls = true;
      video.autoplay = true;
      video.muted = false;

      const source = document.createElement("source");
      source.src = url;
      video.appendChild(source);
      mediaContainer.appendChild(video);

      const finalize = () => {
        mediaContainer.classList.remove("loading");
        scaleMedia(video);
      };
      video.addEventListener("loadeddata", finalize);
      video.addEventListener("canplay", () => scaleMedia(video));
    } else {
      const img = new Image();
      img.onload = () => {
        mediaContainer.classList.remove("loading");
        scaleMedia(img);
      };
      img.src = url;
      img.alt = title;
      mediaContainer.appendChild(img);
    }

    titleEl.textContent = title;
    
    // Parse tags and display up to 5
    let tags = [];
    try {
      tags = JSON.parse(tagsJson);
    } catch (e) {
      console.error("Error parsing tags:", e);
    }

    let tagsHtml = "";
    if (tags && tags.length > 0) {
      const displayTags = tags.slice(0, 5);
      const tagBadges = displayTags.map(tag => {
        const tagUrl = tag.url || "#";
        const tagName = decodeText(tag.name || "");
        return `<a href="${tagUrl}" class="lightbox-tag-badge" onclick="event.stopPropagation()">#${tagName}</a>`;
      }).join(" ");
      
      // Add "+N more" indicator if there are more than 5 tags
      const moreIndicator = tags.length > 5 
        ? `<a href="${detailUrl}" class="lightbox-tag-badge" onclick="event.stopPropagation()">+${tags.length - 5}</a>`
        : "";
      
      tagsHtml = `<div class="lightbox-tags" style="margin-top: 8px;">${tagBadges}${moreIndicator}</div>`;
    }

    metaEl.innerHTML = `
      by ${uploader} · ${created} · <a href="${detailUrl}">View details</a>
      ${tagsHtml}
    `;

    counterEl.textContent = `${currentIndex + 1} / ${items.length}`;

    navLeft.style.display = currentIndex > 0 ? "flex" : "none";
    navRight.style.display = currentIndex < items.length - 1 || infiniteScrollState.nextPage ? "flex" : "none";
  }

  // Load more items when approaching the end
  function loadMoreIfNeeded() {
    if (currentIndex >= items.length - 3 && infiniteScrollState.nextPage && !isLoadingMore && !infiniteScrollState.loading) {
      isLoadingMore = true;
      const loader = document.getElementById("infinite-loader");
      
      const url = new URL(window.location.href);
      url.searchParams.set("page", infiniteScrollState.nextPage);

      fetch(url, { headers: { "X-Requested-With": "XMLHttpRequest" } })
        .then(r => r.json())
        .then(data => {
          if (data.html) {
            grid.insertAdjacentHTML("beforeend", data.html);
            collectItems();
            infiniteScrollState.nextPage = data.has_next ? data.next_page_number : null;
            renderMedia();
          }
        })
        .finally(() => {
          isLoadingMore = false;
        });
    }
  }

  function open(el) {
    collectItems();
    currentIndex = items.indexOf(el);
    if (currentIndex === -1) return;
    show();
    renderMedia();
    loadMoreIfNeeded();
  }

  function prev() { 
    if (currentIndex > 0) { 
      currentIndex--; 
      renderMedia(); 
    } 
  }

  function next() { 
    if (currentIndex < items.length - 1) { 
      currentIndex++; 
      renderMedia(); 
      loadMoreIfNeeded();
    } else if (infiniteScrollState.nextPage && !isLoadingMore) {
      loadMoreIfNeeded();
      setTimeout(() => {
        if (currentIndex < items.length - 1) {
          currentIndex++;
          renderMedia();
        }
      }, 500);
    }
  }

  // Events
  document.addEventListener("click", e => {
    const t = e.target.closest("[data-meme-open]");
    if (t) { e.preventDefault(); open(t); }
  });
  closeBtn.addEventListener("click", hide);
  navLeft.addEventListener("click", prev);
  navRight.addEventListener("click", next);
  lightbox.addEventListener("click", e => { if (e.target === lightbox) hide(); });

  document.addEventListener("keydown", e => {
    if (!lightbox.classList.contains("active")) return;
    if (e.key === "Escape") hide();
    if (e.key === "ArrowLeft") prev();
    if (e.key === "ArrowRight") next();
  });

  // Touch swipe
  let tx = 0;
  lightbox.addEventListener("touchstart", e => tx = e.changedTouches[0].screenX, { passive: true });
  lightbox.addEventListener("touchend", e => {
    const dx = e.changedTouches[0].screenX - tx;
    if (Math.abs(dx) > 50) dx > 0 ? prev() : next();
  }, { passive: true });

  // Resize
  window.addEventListener("resize", () => {
    if (lightbox.classList.contains("active")) {
      const m = mediaContainer.querySelector("img, video");
      if (m) scaleMedia(m);
    }
  });

  // Expose state updater for infinite scroll script
  window.updateLightboxScrollState = function(nextPage, loading) {
    infiniteScrollState.nextPage = nextPage;
    infiniteScrollState.loading = loading;
    if (lightbox.classList.contains("active")) {
      collectItems();
      renderMedia();
    }
  };
})();
</script>

{% endblock %}
